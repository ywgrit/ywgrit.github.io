<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>memory type</title>
    <link href="/memory-type/"/>
    <url>/memory-type/</url>
    
    <content type="html"><![CDATA[<h1 id="Memory-Type"><a href="#Memory-Type" class="headerlink" title="Memory Type"></a>Memory Type</h1><h2 id="什么是Memory-Type"><a href="#什么是Memory-Type" class="headerlink" title="什么是Memory Type"></a>什么是Memory Type</h2><p>每个内存区域都有自己的memory type，代表此内存区域的一些特性，例如数据是否会使用cache、访存操作是否可以reorder等等</p><p>Linux下可以通过以下命令查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /sys/kernel/debug/x86/pat_memtype_list<br></code></pre></td></tr></table></figure><p>目前IA32中的memory type如下表所示</p><table><thead><tr><th>Memory Type and Mnemonic</th><th>read cacheable</th><th>write cacheable</th><th>read allocate</th><th>write allocate</th><th>Allows Speculative Reads</th><th>Memory Ordering Model</th></tr></thead><tbody><tr><td>Strong Uncacheable(UC)</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Strong Ordering</td></tr><tr><td>Uncacheable (UC-)</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Strong Ordering. Can only be selected through the PAT. Can be overridden by WC in MTRRs.</td></tr><tr><td>Write Combining (WC)</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td><td>Weak Ordering. Available by programming MTRRs or by selecting it through the PAT.</td></tr><tr><td>Write-through (WT)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Speculative Processor Ordering</td></tr><tr><td>Write Back(WB)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Speculative Processor Ordering</td></tr><tr><td>Write protected(WP)</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td><td>Speculative Processor Ordering. Available by programming MTRRs.</td></tr></tbody></table><ul><li><p><strong>Strong Uncacheable(UC)</strong> : 对于UC的内存读写操作都不会写到cache里，不会被reordering。</p><ul><li><p>对于memory-mapped I&#x2F;O device，UC很适用。SMP 系统上，各个 CPU 可以通过支持 <a href="https://zhuanlan.zhihu.com/p/95435168">cache 一致性协议</a>的总线 snoop 到其他 CPU 对 cache 的读写，而通过 PCIe 连接的 CPU 和 GPU 则不能互相 snoop，如图一所示，因此从 CPU 的角度，显存算是 I&#x2F;O memory，对其访问需要是 uncachable 的（注1）。reordering也会导致I&#x2F;O device读到dirty data，比如说I&#x2F;O device把这些内存作为一些控制用的寄存器使用。</p><p><img src="/../img/memory_type/cpu_gpu_access.png" alt="cpu_gpu_access">对于普通用途的内存，UC会导致性能的急剧下降。</p></li></ul><blockquote><p>注1: 一种例外是，有些I&#x2F;O device支持bus coherency protocol，可以和CPU保持cache一致性，这样的话是可以使用cacheable的内存的，但是这种总线协议也是有代价的。</p></blockquote></li><li><p><strong>Uncacheable (UC-)</strong>: 和UC类型一样，除了UC- memory type可以通过设置MTRRs被改写为WC memory type.</p></li><li><p><strong>Write Combining (WC)</strong>: <a href="https://download.intel.com/design/PentiumII/applnots/24442201.pdf">文档</a>，WC内存不会被cache，bus coherency protcol不会保证WC内存的读写。在WC类型的内存上的写操作会被延迟，数据会在cpu的<strong>WC buffer</strong>上被组合，这样可以减少总线上的访存操作。对同一地址的连续写，以最后一次写入的为准。</p><p>显存作为 frame buffer 有个特点，就是它容许对不同地址写操作的 combine 和 reorder（写入不同像素点的数据往往是不相关的），这和普通的 MMIO 是不同的，因此就有了 WC 这种相对特殊的类型</p><blockquote><p>注2: Speculative read是指读之前并不验证内存的有效性，先冒险的读进来，如果发现不是有效数据再取消读取操作，并更新内存后再读取. 比如说数据还是被buffer在WC buffer中</p></blockquote></li><li><p>**Write back(WB)**：read 和 write 都 cache，在read 或者write miss时，都会同步写入数据到cache中</p></li><li><p>**Write Through(WT)**：read 时 cache，write hit 时同步写入 cache line 和 main memory，而 write miss 时不分配 cache line（即没有 write allocate），直接写入 memory</p></li><li><p><strong>Write protected(WP)</strong>: 读操作和WT&#x2F;WB没有什么区别，读会被cache. 写不一样，写的时候会在bus上传播这个操作，并且导致其他处理器上的cache lines被更新。主要用于多处理器的情况。WP的内存，在写的时候就会更新其他处理器上的cache,而WB&#x2F;WT类型的内存需要等到其他处理读的时候才会去更形无效的cache</p></li></ul><p>上述几种内存属性中，WB理论上性能最好，因为既不会使用cache，又可以reordering</p><p><img src="/../img/memory_type/memory_reorder.png" alt="memory_reorder"></p><p>可以得知，cache和out-of-order并不是两个独立的特性，memory type将他们交织在了一起</p><h1 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">_mm_prefetch(<span class="hljs-type">char</span> <span class="hljs-type">const</span>* p, <span class="hljs-type">int</span> i);<br></code></pre></td></tr></table></figure><p>从地址P处预取尺寸为cache line大小的数据缓存，参数i指示预取方式（_MM_HINT_T0, _MM_HINT_T1, _MM_HINT_T2, _MM_HINT_NTA，分别表示不同的预取方式）</p><ul><li>T0 预取数据到所有级别的缓存，包括L0</li><li>T1 预取数据到除L0外所有级别的缓存</li><li>T2 预取数据到除L0和L1外所有级别的缓存</li><li>NTA  预取数据到非临时缓冲结构中，可以最小化对缓存的污染</li></ul><p>NTA：non-temporal aligned，程序告诉处理器应该尽可能地避免以这个数据污染cache，因为数据只在一段很短的期间内会被使用</p><p>non-temporal的含义</p><ul><li>将数据放入cache，但假设只使用一次。通常的实现方法是加载数据，但偏置 “最近最少使用 “位，这样新加载的行将被视为 “最近最少使用”，而不是默认的 “最近使用”。 PREFETCHNTA 指令似乎就是这样做的。 PREFETCHNTA 还会将数据拉入 L1 数据缓存（因此在被逐出时，不必被放入到 L2 或者更高层次的缓存中），但不会将数据放入到 L2 或 L3。</li><li>不将数据放在cache中，而是将其放在单独的cacheline大小的缓冲区，即WC Buffer中，以允许多次连续（部分cacheline）加载。 这就是 MOVNTDQA 和 VMOVNTDQA 指令的作用。 它们用于WC内存类型。</li></ul><p>因此</p><ul><li>在system memory中时，memory type一般不是WC，NT的作用是将数据尽可能快地从cache中逐出</li><li>在属性为WC的内存中，NT的作用是使用cpu的internal wirte buffer，不将数据放入到cache中。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>IA32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023:what does not kill me makes me stronger</title>
    <link href="/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>​很明显，这是一篇迟到的年终总结。方便起见，以下的“今年“代指2023年，“去年“代指2022年。</p><p>​纠结了很久是否应该写所谓的总结，怕写下来全篇都是对公司的控诉。过去的一年，尤其是下半年无任何作为。但最近半年内遇到的问题太多，还是需要在这里记录下来。</p><p>​想好好地记录，但真到这个时候情绪又变得激动起来了。因此下面的话基本是想到啥写啥。</p><p>​入职前的期待和现在的失望形成的反差让去年的我不敢相信。事实上，在入职一周后我就很不安了，但是三方已经签了，其余几个offer也都已经拒绝了。</p><p>​那入职前有何期待？现在又失望在何处？可能不应该这么描述——我甚至都没办法将对公司无穷的批判限定在“何处“这一范围。但是为了更明确地说明这半年来的心境，还是强行部分具象化。</p><blockquote><ul><li><p>初创公司需要做的事情很多，成长会很大</p><p>需要做的事情确实多，但完全不代表会有成长，因为公司本身都没有强烈的成长意愿（后面会详细解释）。在这艘船上的人想大施拳脚更是不可能的事。</p></li><li><p>外企风格给员工带来的压力会小很多</p><p>确实没什么压力，但是摸鱼现象渗透到了各个level——不得不用公司混乱的lv设定来表述了，甚至到了严重影响公司产品规划的程度。不过，在我看来，公司也没有明确的规划，或者顶多算是一次次不存在任何记录的空谈。</p></li><li><p>在数据库领域扬帆起航</p><p>门都没入，更没帆扬</p></li></ul></blockquote><p>​先来总结一下为什么我会加入到这家公司：</p><ul><li>信息差，公司</li><li>没有非常吸引我的offer</li></ul><p>我已经不准备再和任何公司内部的人谈论任何“污蔑”公司的话题（引用我和几个同事对此事的交谈过程），不是因为对不合群的顾虑，而是在双方不能都达到一定的人性高度时，人与人之间不光悲欢不相通，价值观更不能相容。</p><p>最近一年来，对工作这件事的看法已经改变了许多，和陈海波实验室的老哥聊到此事时，他提到不会太看重工作内容，而会更注重工作形式，即工作是否开心。这也是他从操作系统方向转为数据库的原因吧。</p><p>由于对所处环境过于痛苦和对前景的困惑，上周五向已经离职的同事求助——是的，我又双叒叕败下阵来了。对方提到情绪价值是非常重要的，这会直接影响我们对工作的热情以及自驱学习的动力。天呐，我竟然才意识到，以前以为自己无所不能的我，终于明白了为什么即使已经没有任何事情，即使是下班时间，我也再没有任何动力去学习我那在从前热爱的computer system了。即使是带着“和命运的抗争”这样具有使命感的心态，似乎也做不到了。</p><p>不过，似乎这无尽的失望中还存在一些值得记录的地方。在长达半年多的</p><p>本文是一次“记录“，因此全文中所有对环境的“控诉“都是为了更好地对自己做反思，就像前面提到的，如果自己足够强大，可能甚至都不需要记录得如此详实了。</p><p>就像文章标题一样，关注我的朋友们也不用替我担心，时刻保持英雄主义可能就是我的使命感。</p><p>为了摆脱糟糕的情绪和落实跳槽这一想法，需要每天给自己制定明确的目标，至少是从每周以及每个月的，如果是24年6月跳槽，那么时间已经非常紧了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
